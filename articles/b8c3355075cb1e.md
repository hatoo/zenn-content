---
title: "Rustのパーサーライブラリ、Chumskyの紹介"
emoji: "🦀"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["Rust"]
published: false
---

# はじめに

この記事ではRustのパーサーライブラリ、[Chumsky](https://github.com/zesterer/chumsky)に入門していきます。
始めにChumskyの簡単な説明をして、そのあとに実践例として[Learn LLVM 12](https://www.packtpub.com/product/learn-llvm-12/9781839213502)に載っている`calc`言語をパースしていきます。
`calc`自体は非常に単純な言語ですが、後々読者が自作言語のパースを行うことを考え、そこそこ丁寧に実装していきます。
もちろんこの記事を読むにあたってLearn LLVM 12を読む必要はありませんがLLVMを使ったコード生成に興味がある方は読むことをおすすめします。

## 参考リンク

* [Chumsky](https://github.com/zesterer/chumsky)
    本書で紹介するChumskyのリポジトリ
* [Ariadne](https://github.com/zesterer/ariadne)
    エラー表示用のライブラリ。Chumskyと同じ作者が作っている
* [Tao](https://github.com/zesterer/tao)
    Chumskyと同じ作者が作っているプログラミング言語。パーサーにChumskyを使っているので例を見るのにちょうど良い

# Chumskyとは

[Chumsky](https://github.com/zesterer/chumsky)はRust用のパーサーライブラリで、他のパーサーライブラリと比べると

* エラー処理に力を入れている
* [Ariadne](https://github.com/zesterer/ariadne)と連携することでかっこいいエラー表示ができる。(もちろん他のパーサーでもAriadneを使うことはできます)
* トークン列用のパーサーから元の文字列の範囲(スパン)を取れる

などの特徴があり、個人的には自作プログラミング言語用のパーサーを作るのにかなり適していると感じています。

## パフォーマンス

パフォーマンスはChumskyの最優先事項ではないようですが、現在開発中のZero-Copy parsing機能(マッチした文字列を`String`ではなく元の入力への`&str`で取る機能)を使ったベンチマークでは`JSON`のパースが`nom`よりも速いという結果が出ています(これはおどろき)。[#94](https://github.com/zesterer/chumsky/pull/94)

# Chumsky入門

Chumskyはいわゆるパーサーコンビネーターライブラリです。色々なパーサーを組み合わせて目的のパーサーを作っていきます。

例として、`yyyy/mm/dd`の形式の日付のパーサーを書いてみます。
各数字の桁数が想定と違う場合はエラーを報告しつつ、パースは続けていくようにします。

```rust
use chumsky::prelude::*;

// パーサーの具体的な型は多くの場合書くことが不可能なため`impl ...`を使う
// Errorとして`chumsky::error::Simple`を使う。自分でエラー型を定義して独自のエラーを保持するようにすることもできる。
fn yyyy_mm_dd() -> impl Parser<char, (u32, u32, u32), Error = Simple<char>> {
    // len桁の数字のパーサー
    let number = |len| {
        // 10進法の数字列
        text::digits(10)
            // 出力をバリデートする
            // 数字列の桁数が`len`でない場合エラーを報告するが。パース処理はそのまま続く
            .validate(move |number: String, span, emit| {
                // [0-9]+の文字列なのでバイト長がそのまま文字列の長さになる
                if number.len() != len {
                    // エラーを報告
                    // どのようなエラーが報告できるかは後述する
                    emit(Simple::custom(
                        span,
                        format!("length of a number must be {}, but got {}", len, &number),
                    ))
                }
                number
            })
            // 数字列をu32に変換する
            // 例えば数字が大きすぎてu32に変換できないときはもうどうしようもないのでパースを打ち切る
            .try_map(|number, span| {
                number.parse().map_err(|_| {
                    Simple::custom(span, format!("{} is an invalid u32 string", &number))
                })
            })
    };

    // yyyy
    number(4)
        // ラベルを付けるとエラー時にわかりやすくなる
        .labelled("yyyy")
        // '/'にマッチさせその結果は破棄する
        .then_ignore(
            // 名前の通り`just`は引数の文字列にそのままマッチする
            just('/').labelled("between yyyy and mm"))
        // mm
        // thenでパーサーをつなげると双方の結果がタプルで得られる
        .then(number(2).labelled("mm"))
        .then_ignore(just('/').labelled("betweel mm and dd"))
        // dd
        .then(number(2).labelled("dd"))
        .map(|((y, m), d)| (y, m, d))
}

#[test]
fn test_yyyy_mm_dd() {
    assert_eq!(yyyy_mm_dd().parse("2020/03/19").unwrap(), (2020, 03, 19));
    assert!(yyyy_mm_dd().parse("20201/03/19").is_err());

    // エラーがあってもそのままパースを続ける
    assert_eq!(
        yyyy_mm_dd().parse_recovery("20201/03/19").0,
        Some((20201, 03, 19))
    );
}
```

エラーの型に[`chumsky::error::Simple`](https://docs.rs/chumsky/0.8.0/chumsky/error/struct.Simple.html)を使用しました。
この記事では行いませんが独自のエラーを記録するためにエラー型を自分でつくることもできます。
Chumskyにビルトインで入っている`chumsky::error::Simple`もいくつかのエラーの種類を記録することができます。

```rust
pub enum SimpleReason<I, S> {
    // 予期しない入力が来た
    Unexpected,
    // かっこの対応が取れていない
    Unclosed {
        span: S,
        delimiter: I,
    },
    // カスタムのエラーメッセージ
    Custom(String),
}
```

# Ariadne入門

Ariadneはエラー出力用のライブラリです。

![ariadne](/images/ariadne.png)

こんな感じでかっこよくエラーを表示することができます。

上記のエラー出力をする例

```rust
use ariadne::{Color, Fmt, Label, Report, ReportKind, Source};

fn main() {
    let src_id = "input.txt";
    let src = "2022a/03/19";

    Report::build(ReportKind::Error, src_id, 4)
        .with_message("Unexpected char")
        .with_label(
            Label::new((src_id, 4..5))
                .with_message(format!("unexpected char {}", "a".fg(Color::Red))),
        )
        .finish()
        .print((src_id, Source::from(src)))
        .unwrap();
}
```

大体見ただけでわかると思いうので、Ariadneで上記のパーサーのエラー出力をやっていきます。



# `calc`の説明

この記事ではLearn LLVM 12ででてくる`calc`をパースしてASTを作っていくので、`calc`の説明をしていきたいと思います。

`calc`の文法はこんな感じです。だいたいわかると思います。

```
calc : ("with" ident ("," ident)* ":")? expr
expr : term (("+" | "-") term)*
term : factor (("*" | "/") factor)*
factor : ident | number | "(" expr ")"
ident : ([a-zA-Z])+
number : ([0-9])+
```

やっていることは変数を宣言して(もしくはしないで)四則演算を行うだけです

例:

```
# exprのみ。3が返ってくる
1 + 2
# 入力としてa, bをとってa+bを計算する
with a, b : a + b
```

# Lexerをつくる

さっそくLexerを作っていきます

## トークンの型を定義する

まず、トークンの型を定義します。`Clone`, `Hash`は`Lexer`を書くとき、`Debug`, `PartialEq`はテストを書くときに必要なので`derive`しています。`Eq`はついでです。

```rust:token.rs
#[derive(Clone, Debug, PartialEq, Eq, Hash)]
pub enum Token {
    With,
    // 今回は使わないが、自作言語を作る場合は`internment`クレートなどを使ってIdent同士の比較などを速くしよう
    Ident(String),
    Number(u32),
    Comma,
    Colon,
    Plus,
    Minus,
    Star,
    Slash,
    LParen,
    RParen,
    // 上記にマッチしない文字。今回はこれを後で使うことはない
    Error(char),
}
```