---
title: "「SipHash」とそのRustの実装について調べてみた"
emoji: "#️⃣"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["rust", "siphash", "hash"]
published: false
---

この記事は[Rust Advent Calendar 2023](https://qiita.com/advent-calendar/2023/rust)の14日目の記事です。

# はじめに

[SipHash](https://web.archive.org/web/20180829083106/http://131002.net/siphash/)はRustの標準ライブラリの[`std::collections::HashMap`](https://doc.rust-lang.org/std/collections/struct.HashMap.html)などでデフォルトで使われるハッシュアルゴリズムです。
HashDos攻撃に対する耐性がありデフォルトのアルゴリズムとして相応しいですが、個人的にHashMapの速度を上げたいときに適当に(耐性のない)他のアルゴリズムに変えてしまいがちなので、今回ちゃんと調べてみました。

# SipHashとは

## Overview

SipHashは[PRF](https://en.wikipedia.org/wiki/Pseudorandom_function_family)の一種で

```mermaid
graph LR
    SecretKey -- 128 bits --> SipHash
    Input -- any bits --> SipHash
    SipHash -- 64 bits --> Hash
```

128bitの秘密鍵と任意の長さの入力から64bitのハッシュ値を生成します。
秘密鍵の内容がバレていない限り、入力がどのようなハッシュ値になるかは予測できないのでHashDos攻撃に対して耐性があるというわけです。

### Rustでの秘密鍵の生成

Rustの標準ライブラリでは秘密鍵の生成に、最初だけちゃんとOSから乱数を取得してそれ以降はその値をthread_localに保持して一個ずつインクリメントしていくという方法を取っています。

https://github.com/rust-lang/rust/blob/1a3aa4ad149438a9b11f758c16df9e222de51f91/library/std/src/hash/random.rs#L55

毎回OSから乱数を取得すると遅かったということがコメントに書いてあります。

## アルゴリズム

SipHashのアルゴリズムを[Rustの標準ライブラリの実装](https://github.com/rust-lang/rust/blob/1a3aa4ad149438a9b11f758c16df9e222de51f91/library/core/src/hash/sip.rs)とともに見ていきます。

1. k0, k1のu642つ、合計128bitの秘密鍵と固定値で内部状態を初期化する

```rust
#[derive(Debug, Clone, Copy)]
#[repr(C)]
struct State {
    // v0, v2 and v1, v3 show up in pairs in the algorithm,
    // and simd implementations of SipHash will use vectors
    // of v02 and v13. By placing them in this order in the struct,
    // the compiler can pick up on just a few simd optimizations by itself.
    v0: u64,
    v2: u64,
    v1: u64,
    v3: u64,
}


impl<S: Sip> Hasher<S> {
    #[inline]
    const fn reset(&mut self) {
        self.length = 0;
        self.state.v0 = self.k0 ^ 0x736f6d6570736575;
        self.state.v1 = self.k1 ^ 0x646f72616e646f6d;
        self.state.v2 = self.k0 ^ 0x6c7967656e657261;
        self.state.v3 = self.k1 ^ 0x7465646279746573;
        self.ntail = 0;
    }
}
```

XORしてる固定値は`b'somepseudorandomgeneratedbytes'`のASCIIコードから来ています
とにかくv0-3の各状態が別の値になればいいっぽいです。

```python
>>> ''.join(['%x' % c for c in b'somepseudorandomgeneratedbytes'])
'736f6d6570736575646f72616e646f6d67656e6572617465646279746573'
```