---
title: "Aeneasã§Rustãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ¤œè¨¼ã—ã¦ã¿ãŸ"
emoji: "ğŸ“˜"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["aeneas", "rust", "lean"]
published: false
---

# ã¯ã˜ã‚ã«

[Aeneas](https://github.com/AeneasVerif/aeneas)ã¯Rustãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ¤œè¨¼ã™ã‚‹ãŸã‚ã®ãƒ„ãƒ¼ãƒ«ãƒã‚§ã‚¤ãƒ³ã§ã™ã€‚
[Charon](https://github.com/AeneasVerif/charon)ãŒRustã‚³ãƒ¼ãƒ‰ã‚’LLBCã¨å‘¼ã°ã‚Œã‚‹å½¢å¼ã«å¤‰æ›ã—ã¦ãã‚Œã¦ã€ãã‚Œã‚’Aeneasã«èª­ã¾ã›ã‚‹ã¨F*, Coq, HOL4, LEANã®ã‚³ãƒ¼ãƒ‰ã«å¤‰æ›ã—ã¦ãã‚Œã¾ã™ã€‚

ç­†è€…ã¯Leanåˆå¿ƒè€…ã§ã™ãŒã€ä»Šå›ã¯å®Ÿéš›ã«Rustã‚³ãƒ¼ãƒ‰ã‚’Leanã§æ¤œè¨¼ã—ã¦ã¿ã‚ˆã†ã¨æ€ã„ã¾ã™ã€‚

```mermaid
graph TB
    Rustã‚³ãƒ¼ãƒ‰ -->|Charon| LLBC
    LLBC -->|Aeneas| Lean
```

# Aeneasã®Rustãƒ¢ãƒ‡ãƒ«

Aeneasã®Leanã‚³ãƒ¼ãƒ‰ã§ã¯Rustã®å¼ã‚’è©•ä¾¡ã—ãŸçµæœã¨ã—ã¦ä»¥ä¸‹ãŒå®šç¾©ã•ã‚Œã¦ã„ã¾ã™

```lean
inductive Error where
   | assertionFailure: Error -- assertionå¤±æ•—
   | integerOverflow: Error -- ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ ç‰¹ã«ãƒªãƒªãƒ¼ã‚¹ãƒ“ãƒ«ãƒ‰ã§ã¯ãƒã‚§ãƒƒã‚¯ã•ã‚Œãªã„ã‚„ã¤
   | divisionByZero: Error -- 0é™¤ç®—
   | arrayOutOfBounds: Error -- é…åˆ—ã®ç¯„å›²å¤–ã‚’å‚ç…§ã—ãŸ
   | maximumSizeExceeded: Error -- é…åˆ—ã®ã‚µã‚¤ã‚ºãŒusizeã‚’è¶…ãˆãŸ
   | panic: Error -- ãƒ‘ãƒ‹ãƒƒã‚¯
   | undef: Error -- æœªå®šç¾©
deriving Repr, BEq

open Error

inductive Result (Î± : Type u) where
  | ok (v: Î±): Result Î± -- æˆåŠŸ
  | fail (e: Error): Result Î± -- ãã‚Œä»¥å¤–
  | div -- ã“ã‚Œã¯Nonemptyã‚¯ãƒ©ã‚¹ã‚’å®Ÿè£…ã™ã‚‹ãŸã‚ã ã‘ã®ã‚„ã¤ã ã¨æ€ã†ã®ã§ç„¡è¦–
deriving Repr, BEq
```

ä¾‹ãˆã°ã€ã‚ã‚‹é–¢æ•°ãŒ(ã‚ã‚‹çŠ¶æ³ä¸‹ã§)å¿…ãšæˆåŠŸã™ã‚‹ã“ã¨ã¨ã‹ãŒè¨¼æ˜ã§ãã‚Œã°ã†ã‚Œã—ãã†

# ã‚„ã£ã¦ã¿ã‚‹

å®Ÿéš›ã«ãªã«ã‹è¨¼æ˜ã—ã¦ã¿ã¾ã™

é©å½“ã«Rustãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œã‚Šã¾ã™
```sh
cargo new sandbox
```

é©å½“ã«é–¢æ•°ã‚’å®šç¾©ã—ã¾ã™

```rust:main.rs
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}
```

Charonã§LLBCã«å¤‰æ›ã—ã¾ã™

```sh
charon cargo --preset=aeneas
```

ã“ã‚Œã§`sanbox.llbc`ãŒã§ãã¾ã™ã€‚
LLBCè‡ªä½“ã¯JSONã§ã™ãŒä¸­èº«ã¯äººç”¨ã§ã¯ãªã„ã®ã§ã‚ˆãã‚ã‹ã‚Šã¾ã›ã‚“ã€‚

aeneasã§Leanã«å¤‰æ›ã—ã¾ã™

```sh
aeneas -backend lean sandbox.llbc
```

ã“ã‚Œã§Rustãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’Leanã«å¤‰æ›ã—ãŸã‚„ã¤ãŒã§ãã¾ã™

```lean:Sandbox.lean
-- THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS
-- [sandbox]
import Aeneas
open Aeneas.Std Result Error
set_option linter.dupNamespace false
set_option linter.hashCommand false
set_option linter.unusedVariables false

namespace sandbox

/- [sandbox::main]:
   Source: 'src/main.rs', lines 1:0-1:12 -/
def main : Result Unit :=
  ok ()

/- [sandbox::add]:
   Source: 'src/main.rs', lines 3:0-5:1 -/
def add (a : I32) (b : I32) : Result I32 :=
  a + b
```

ã‚ã¨ã¯é©å½“ã«Leanãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œã£ã¦Aeneasã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’è¿½åŠ ã—ã¦å¥½ãã«ã™ã‚‹ã ã‘ã§ã™ã€‚

```lean:Basic.lean
import Aeneas
import RustVerify.Sandbox

open Aeneas.Std Result Error

theorem add_spec {a b : I32} (hâ‚€ : I32.min â‰¤ â†‘a + â†‘b) (hâ‚ : â†‘a + â†‘b â‰¤ I32.max) :
  âˆƒ c, sandbox.add a b = ok c âˆ§ (â†‘c: â„¤) = â†‘a + â†‘b := by
  unfold sandbox.add
  apply I32.add_spec hâ‚€ hâ‚
```

aã¯I32ãªã®ã§a + bã¯Result I32ã§ã™ãŒâ†‘aã¯aã®ä¸­èº«ã®æ•´æ•°å‹ãªã®ã§â†‘a + â†‘bã¯Leanã®æ•´æ•°å‹ã§ã™

I32.min â‰¤ â†‘a + â†‘b ã‹ã¤ â†‘a + â†‘b â‰¤ I32.max ãªã‚‰

```rust
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}
```
ã¯å¸¸ã«æˆåŠŸã—ã¦ãã®ã¨ãè¿”ã‚Šå€¤ã¯â†‘a + â†‘bã¨ã„ã†ã“ã¨ã‚’è¡¨ã—ã¦ã„ã¾ã™

ã“ã‚Œã ã¨ã‚ãŸã‚Šã¾ãˆä½“æ“ã™ãã‚‹ã®ã§ã‚‚ã†ã¡ã‚‡ã£ã¨é ‘å¼µã£ã¦ã¿ã¾ã™

# è‡ªåˆ†ã®PCGé–¢æ•°ãŒå¸¸ã«æˆåŠŸã™ã‚‹ã“ã¨ã‚’è¨¼æ˜ã—ã¦ã¿ã‚‹

ç­†è€…ã¯é€Ÿã„ä¹±æ•°ãŒæ¬²ã—ã„ã¨ãã«ã‚ˆãPCGã®`Pcg64Si`ã‚’æ›¸ãã®ã§ã™ãŒãã‚Œã‚’ã‚„ã£ã¦ã¿ã¾ã™ã€‚

https://github.com/hatoo/oha/blob/a0002913331784299102d6dfe6d469ff7e4db2d5/src/pcg64si.rs#L1-L31

`rand::RngCore`ã¨ã‹ã‚’ä½¿ã†ã¨CharonãŒæ–‡å¥ã‚’ã„ã†ã®ã§èˆˆå‘³ãŒã‚ã‚‹éƒ¨åˆ†ã ã‘æŠœãå‡ºã—ã¾ã™

```rust
#[repr(transparent)]
pub struct Pcg64Si {
    state: u64,
}

impl Pcg64Si {
    pub fn next_u64(&mut self) -> u64 {
        let old_state = self.state;
        self.state = self
            .state
            .wrapping_mul(6364136223846793005)
            .wrapping_add(1442695040888963407);

        let word =
            ((old_state >> ((old_state >> 59) + 5)) ^ old_state).wrapping_mul(12605985483714917081);
        (word >> 43) ^ word
    }
}
```

Aeneasã®çµæœãŒã“ã¡ã‚‰ã€‚å‰²ã¨ã‚ã‹ã‚Šã‚„ã™ã„

```lean:Sandbox.lean
/- [sandbox::{sandbox::Pcg64Si}::next_u64]:
   Source: 'src/main.rs', lines 13:4-23:5 -/
def Pcg64Si.next_u64 (self : Pcg64Si) : Result (U64 Ã— Pcg64Si) :=
  do
  let i â†
    (â†‘(core.num.U64.wrapping_mul self.state 6364136223846793005#u64) : Result
      U64)
  let i1 â†
    (â†‘(core.num.U64.wrapping_add i 1442695040888963407#u64) : Result U64)
  let i2 â† self.state >>> 59#i32
  let i3 â† i2 + 5#u64
  let i4 â† self.state >>> i3
  let i5 â† (â†‘(i4 ^^^ self.state) : Result U64)
  let word â†
    (â†‘(core.num.U64.wrapping_mul i5 12605985483714917081#u64) : Result U64)
  let i6 â† word >>> 43#i32
  let i7 â† (â†‘(i6 ^^^ word) : Result U64)
  ok (i7, { state := i1 })
```

```lean:Basic.lean
@[progress]
theorem UScalar.xor_spec {ty} (x y : UScalar ty) :
  âˆƒ z, toResult (x ^^^ y) = ok z âˆ§ z.val = (x ^^^ y).val âˆ§ z.bv = x.bv ^^^ y.bv := by
  simp [toResult]
  rfl

theorem Pcg64Si.next_u64_no_panic (self : sandbox.Pcg64Si) :
  âˆƒ res : U64 Ã— sandbox.Pcg64Si, self.next_u64 = ok res := by
  unfold sandbox.Pcg64Si.next_u64
  progress*
```

`self.next_u64()`ã¯å¿…ãšæˆåŠŸã™ã‚‹

## ã¡ã‚‡ã£ã¨Lean

`progress` tacticã¯`progress` attributeãŒã¤ã„ãŸ

```lean
theorem thm_name (arg1 : ty1) ... (argn : tyn)
  (h_pre1 : precondition_1) ... (h_prem : precondition_m) :
  âˆƒ (res1 : res_ty1) ... (resk : res_tyk),
    f arg1 ... argn = ok res1 âˆ§ postcondition_1 âˆ§ ... âˆ§ postcondition_k
```

ã¿ãŸã„ãªtheoremã‹ã‚‰ä½¿ãˆãã†ãªã‚„ã¤ã‚’æ¢ã—ã¦ã‚´ãƒ¼ãƒ«ã®ãƒ¢ãƒŠãƒ‰ã‚’é€²ã‚ã¦ãã‚Œã¾ã™

`progress*`ã¯`progress`ã‚’åå¾©ã—ã¦ã‚„ã£ã¦ãã‚Œã¾ã™

ã“ã®ä¾‹ã§ã¯`xor`ã®ãŸã‚ã®progress attributeã®ã¤ã„ãŸtheoremãŒã¾ã ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«ãªã‹ã£ãŸã®ã§è¿½åŠ ã§å®šç¾©ã—ã¦ã„ã¾ã™