---
title: "Xorshiftを統計テストで落とそう！"
emoji: "💭"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: []
published: false
---

# はじめに

素のXorshift^[xoshiroなどの派生アルゴリズムは今回考えません]はよく線形過ぎて質が良くない(意訳)といわれます。
今回は実際に状態数32bitのXorshiftをMatrixRank^[TestU01でいう`smarsa_MatrixRank`]で落としてみましょう^[状態数が32bitと少なめなので他にも多くの落とし方がありますが今回はxorshift特有っぽいやり方でいきます]！

# Xorshiftの復習

C言語のXorshiftの実装コードを確認します。

```c
#include <stdint.h>

struct xorshift32_state {
  uint32_t a;
};

/* The state word must be initialized to non-zero */
uint32_t xorshift32(struct xorshift32_state *state)
{
	/* Algorithm "xor" from p. 4 of Marsaglia, "Xorshift RNGs" */
	uint32_t x = state->a;
	x ^= x << 13;
	x ^= x >> 17;
	x ^= x << 5;
	return state->a = x;
}
```

ご存知の通り、このXorshift特有の
```c
x ^= x << 13 /* なにか定数 */;
```
はビットベクトル上の行列積として表せます。

$$
\exists A : Ax = x \wedge{} (x << c) 
$$

ということで

```c
	x ^= x << 13;
	x ^= x >> 17;
	x ^= x << 5;
```

全部合わせて一個の行列とビットベクトルの積で表せます。

$$
\exists A : Ax = \mathrm{xorshift32}(x)
$$

# じゃあなんなの？

本来理想的な乱数は独立しているべきですがXorshiftの出力は**ビットベクトルとしてみる**と他の出力にめちゃくちゃ依存しています。

$$
x_{n} = Ax_{n-1}
$$

# Matrix Rank

Matrix RankはPRNGの出力を例えば32個くらい取ってそれをビット行列にして行列のランクを取ります。
その分布を理想的な分布と比較してカイ二乗検定すればだめなやつがふるい落とされるというわけです。