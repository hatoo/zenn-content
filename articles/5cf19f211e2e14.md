---
title: "Xorshiftを統計テストで落とそう！"
emoji: "💭"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: []
published: false
---

# はじめに

素のXorshift^[xoshiroなどの派生アルゴリズムは今回考えません]はよく線形過ぎて質が良くない(意訳)といわれます。
今回は実際に状態数32bitのXorshiftをMatrixRank^[TestU01でいう`smarsa_MatrixRank`]で落としてみましょう^[状態数が32bitと少なめなので他にも多くの落とし方がありますが今回はxorshift特有っぽいやり方でいきます]！

# Xorshiftの復習

C言語のXorshiftの実装コードを確認します。

```c
#include <stdint.h>

struct xorshift32_state {
  uint32_t a;
};

/* The state word must be initialized to non-zero */
uint32_t xorshift32(struct xorshift32_state *state)
{
	/* Algorithm "xor" from p. 4 of Marsaglia, "Xorshift RNGs" */
	uint32_t x = state->a;
	x ^= x << 13;
	x ^= x >> 17;
	x ^= x << 5;
	return state->a = x;
}
```

ご存知の通り、このXorshift特有の
```c
x ^= x << 13 /* なにか定数 */;
```
はビットベクトル上の行列積として表せます。

$$
\exists A : Ax = x \wedge{} (x << c) 
$$

ということで

```c
	x ^= x << 13;
	x ^= x >> 17;
	x ^= x << 5;
```

全部合わせて一個の行列とビットベクトルの積で表せます。

$$
\exists A : Ax = \mathrm{xorshift32}(x)
$$

# じゃあなんなの？

本来理想的な乱数は独立しているべきですがXorshiftの出力は**ビットベクトルとしてみる**と他の出力にめちゃくちゃ依存しています。

$$
x_{n} = Ax_{n-1}
$$

# Matrix Rank

Matrix RankはPRNGの出力を例えば32個くらい取ってそれをビット行列にして行列のランクを取ります。
その分布を理想的な分布と比較してカイ二乗検定^[この記事ではしません]すればだめなやつがふるい落とされるというわけです。

以下32x32のビット行列として話をします

## ねらい

一般的にベクトルを線形変換した場合前と他とのベクトルは互いに独立している場合もそうでない場合があります。
ですが少なくとも理想的な乱数と同じようなランクの分布を再現するのは難しいはずです。

## 実装

ビットベクトルのランクは掃き出し法で簡単に求めることができます。

```rust
// Rust
// Matrix rank of bit matrix
pub fn matrix_rank(matrix: &mut [u32]) -> usize {
    let n = matrix.len();
    let mut rank = 0;
    for bit in 0..u32::BITS {
        let mut pivot = None;
        for i in rank..n {
            if (matrix[i] >> bit) & 1 == 1 {
                pivot = Some(i);
                break;
            }
        }
        if let Some(pivot) = pivot {
            matrix.swap(rank, pivot);
            for i in 0..n {
                if i != rank && (matrix[i] >> bit) & 1 == 1 {
                    matrix[i] ^= matrix[rank];
                }
            }
            rank += 1;
        }
    }
    rank
}
```

理想的な乱数からビット行列を作ったときのランクの分布はこんな感じになるはずです^[導出はこの記事ではしません]

![plot of expected rank of 32x32 bit matrix](/images/matrixrank_expected.png)

ちなみに`/dev/random`のランクの分布はこんな感じです

![plot of rank of 32x32 bit matrix from /dev/random](/images/matrixrank_linuxrandom.png)

# 結果

Xorshiftのランクはこんな感じです

![plot of rank of 32x32 bit matrix from xorshift](/images/matrixrank_xorshift.png)

なんと最高ランクしか出ません！

# 緩和策

素のXorshiftはビットの世界で線形なのでMatrixRankに落ちてしまいました。
なのでビットの世界で非線形な変換をすればOKです！

```rust
fn xorshift(state: &mut u32) -> u32 {
    *state ^= *state << 13;
    *state ^= *state >> 17;
    *state ^= *state << 5;
    state.wrapping_add(114514)
}
```

![plot of rank of 32x32 bit matrix from xorshift plus const](/images/matrixrank_xorshiftp.png)