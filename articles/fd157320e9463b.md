---
title: "Aeneasã§Rustãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ¤œè¨¼ã—ã¦ã¿ãŸ"
emoji: "ğŸ›ï¸"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["aeneas", "rust", "lean", "lean4"]
published: false
---

# ã¯ã˜ã‚ã«

[Aeneas](https://github.com/AeneasVerif/aeneas)ã¯Rustãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ¤œè¨¼ã™ã‚‹ãŸã‚ã®ãƒ„ãƒ¼ãƒ«ãƒã‚§ã‚¤ãƒ³ã§ã™ã€‚
[Charon](https://github.com/AeneasVerif/charon)ãŒRustã‚³ãƒ¼ãƒ‰ã‚’LLBCã¨å‘¼ã°ã‚Œã‚‹å½¢å¼ã«å¤‰æ›ã—ã¦ãã‚Œã¦ã€ãã‚Œã‚’Aeneasã«èª­ã¾ã›ã‚‹ã¨F*, Coq, HOL4, LEANã®ã‚³ãƒ¼ãƒ‰ã«å¤‰æ›ã—ã¦ãã‚Œã¾ã™ã€‚

ç­†è€…ã¯Leanåˆå¿ƒè€…ã§ã™ãŒã€ä»Šå›ã¯å®Ÿéš›ã«Rustã‚³ãƒ¼ãƒ‰ã‚’Leanã§æ¤œè¨¼ã—ã¦ã¿ã‚ˆã†ã¨æ€ã„ã¾ã™ã€‚

```mermaid
graph TB
    Rustã‚³ãƒ¼ãƒ‰ -->|Charon| LLBC
    LLBC -->|Aeneas| Lean
```

# Aeneasã®Rustãƒ¢ãƒ‡ãƒ«

Aeneasã®Leanã‚³ãƒ¼ãƒ‰ã§ã¯Rustã®å¼ã‚’è©•ä¾¡ã—ãŸçµæœã¨ã—ã¦ä»¥ä¸‹ãŒå®šç¾©ã•ã‚Œã¦ã„ã¾ã™

```lean
inductive Error where
   | assertionFailure: Error -- assertionå¤±æ•—
   | integerOverflow: Error -- ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ ç‰¹ã«ãƒªãƒªãƒ¼ã‚¹ãƒ“ãƒ«ãƒ‰ã§ã¯ãƒã‚§ãƒƒã‚¯ã•ã‚Œãªã„ã‚„ã¤
   | divisionByZero: Error -- 0é™¤ç®—
   | arrayOutOfBounds: Error -- é…åˆ—ã®ç¯„å›²å¤–ã‚’å‚ç…§ã—ãŸ
   | maximumSizeExceeded: Error -- é…åˆ—ã®ã‚µã‚¤ã‚ºãŒusizeã‚’è¶…ãˆãŸ
   | panic: Error -- ãƒ‘ãƒ‹ãƒƒã‚¯
   | undef: Error -- æœªå®šç¾©
deriving Repr, BEq

open Error

inductive Result (Î± : Type u) where
  | ok (v: Î±): Result Î± -- æˆåŠŸ
  | fail (e: Error): Result Î± -- ãã‚Œä»¥å¤–
  | div -- ã“ã‚Œã¯Nonemptyã‚¯ãƒ©ã‚¹ã‚’å®Ÿè£…ã™ã‚‹ãŸã‚ã ã‘ã®ã‚„ã¤ã ã¨æ€ã†ã®ã§ç„¡è¦–
deriving Repr, BEq
```

# ã‚„ã£ã¦ã¿ã‚‹

å®Ÿéš›ã«ãªã«ã‹è¨¼æ˜ã—ã¦ã¿ã¾ã™

é©å½“ã«Rustãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œã‚Šã¾ã™
```sh
cargo new sandbox
```

é©å½“ã«é–¢æ•°ã‚’å®šç¾©ã—ã¾ã™

```rust:main.rs
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}
```

Charonã§LLBCã«å¤‰æ›ã—ã¾ã™

```sh
charon cargo --preset=aeneas
```

ã“ã‚Œã§`sanbox.llbc`ãŒã§ãã¾ã™ã€‚
LLBCè‡ªä½“ã¯JSONã§ã™ãŒä¸­èº«ã¯äººç”¨ã§ã¯ãªã„ã®ã§ã‚ˆãã‚ã‹ã‚Šã¾ã›ã‚“ã€‚

aeneasã§Leanã«å¤‰æ›ã—ã¾ã™

```sh
aeneas -backend lean sandbox.llbc
```

ã“ã‚Œã§Rustãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’Leanã«å¤‰æ›ã—ãŸã‚„ã¤ãŒã§ãã¾ã™

```lean:Sandbox.lean
-- THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS
-- [sandbox]
import Aeneas
open Aeneas.Std Result Error
set_option linter.dupNamespace false
set_option linter.hashCommand false
set_option linter.unusedVariables false

namespace sandbox

/- [sandbox::main]:
   Source: 'src/main.rs', lines 1:0-1:12 -/
def main : Result Unit :=
  ok ()

/- [sandbox::add]:
   Source: 'src/main.rs', lines 3:0-5:1 -/
def add (a : I32) (b : I32) : Result I32 :=
  a + b
```

ã‚ã¨ã¯é©å½“ã«Leanãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œã£ã¦Aeneasã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’è¿½åŠ ã—ã¦å¥½ãã«ã™ã‚‹ã ã‘ã§ã™ã€‚
ã”å­˜çŸ¥ã®ã‚ˆã†ã«è¶³ã—ç®—ã¯ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ã™ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã®ã§ãã®æ¡ä»¶ã‚’é™½ã«æ›¸ã„ã¦ã„ãã¾ã™ã€‚

```lean:Basic.lean
import Aeneas
import RustVerify.Sandbox

open Aeneas.Std Result Error

theorem add_spec {a b : I32} (hâ‚€ : I32.min â‰¤ â†‘a + â†‘b) (hâ‚ : â†‘a + â†‘b â‰¤ I32.max) :
  âˆƒ c, sandbox.add a b = ok c âˆ§ (â†‘c: â„¤) = â†‘a + â†‘b := by
  unfold sandbox.add
  apply I32.add_spec hâ‚€ hâ‚
```

aã¯I32ãªã®ã§a + bã¯Result I32ã§ã™ãŒâ†‘aã¯aã®ä¸­èº«ã®æ•´æ•°å‹ãªã®ã§â†‘a + â†‘bã¯Leanã®æ•´æ•°å‹ã§ã™

I32.min â‰¤ â†‘a + â†‘b ã‹ã¤ â†‘a + â†‘b â‰¤ I32.max ãªã‚‰

```rust
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}
```
ã¯å¸¸ã«æˆåŠŸã—ã¦ãã®ã¨ãè¿”ã‚Šå€¤ã¯â†‘a + â†‘bã¨ã„ã†ã“ã¨ã‚’ç¤ºã›ã¾ã—ãŸã€‚

# progress tactic

Aeneasã¯Rustã®æ–‡ã¨å¼ã‚’ãƒ¢ãƒŠãƒ‰ã«åˆ†è§£ã—ã¦Leanã«å¤‰æ›ã—ã¾ã™

```rust
pub fn fma(a: i32, b: i32, c: i32) -> i32 {
    a * b + c
}
```

å¤‰æ›å¾Œ

```lean
def fma (a : I32) (b : I32) (c : I32) : Result I32 :=
  do
  let i â† a * b
  i + c
```

ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ã‚’æ•´ç†ã—ã¾ã™

```lean
theorem fma_spec {a b c : I32}
  (hâ‚€ : I32.min â‰¤ â†‘a * â†‘b)
  (hâ‚ : â†‘a * â†‘b â‰¤ I32.max)
  (hâ‚‚ : I32.min â‰¤ â†‘a * â†‘b + â†‘c)
  (hâ‚ƒ : â†‘a * â†‘b + â†‘c â‰¤ I32.max) :
  âˆƒ d, sandbox.fma a b c = ok d âˆ§ (â†‘d: â„¤) = â†‘a * â†‘b + â†‘c := by
  unfold sandbox.fma
```

ã“ã®ã¨ãã‚´ãƒ¼ãƒ«ã¯ä»¥ä¸‹ã«ãªã‚Šã¾ã™

```lean
âŠ¢ âˆƒ d,
  (do
        let i â† a * b
        i + c) =
      ok d âˆ§
    â†‘d = â†‘a * â†‘b + â†‘c
```

ã‚´ãƒ¼ãƒ«ã«ãƒ¢ãƒŠãƒ‰ãŒå…¥ã£ã¦ã„ã‚‹ã®ã§ã“ã®ã¾ã¾ã ã¨ã©ã†ã™ã‚Œã°ã„ã„ã‹ã‚ã‹ã‚Šã¾ã›ã‚“
ã“ã®ã¨ãã«ä½¿ãˆã‚‹ã®ãŒ`progress` tacticã§ã™
`progress`ã‚’ä½¿ã†ã¨`progress` attributeã®ã¤ã„ãŸ

```lean
theorem thm_name (arg1 : ty1) ... (argn : tyn)
  (h_pre1 : precondition_1) ... (h_prem : precondition_m) :
  âˆƒ (res1 : res_ty1) ... (resk : res_tyk),
    f arg1 ... argn = ok res1 âˆ§ postcondition_1 âˆ§ ... âˆ§ postcondition_k
```

ã“ã‚“ãªæ„Ÿã˜ã®theoremã‚’ä½¿ã£ã¦ãƒ¢ãƒŠãƒ‰ã‚’é€²ã‚ã¦ãã‚Œã¾ã™

`*`æ¼”ç®—å­ã®éƒ¨åˆ†ã‚’é€²ã‚ã‚‹

```lean
  progress as âŸ¨x, xhâŸ©
```

ã‚´ãƒ¼ãƒ«

```lean
x : I32
xh : â†‘x = â†‘a * â†‘b
âŠ¢ âˆƒ d, x + c = ok d âˆ§ â†‘d = â†‘a * â†‘b + â†‘c
```

ãªã‚“ã‚„ã‹ã‚“ã‚„ã§ã“ã‚“ãªæ„Ÿã˜ã«ãªã‚Šã¾ã™

```lean
theorem fma_spec {a b c : I32}
  (hâ‚€ : I32.min â‰¤ â†‘a * â†‘b)
  (hâ‚ : â†‘a * â†‘b â‰¤ I32.max)
  (hâ‚‚ : I32.min â‰¤ â†‘a * â†‘b + â†‘c)
  (hâ‚ƒ : â†‘a * â†‘b + â†‘c â‰¤ I32.max) :
  âˆƒ d, sandbox.fma a b c = ok d âˆ§ (â†‘d: â„¤) = â†‘a * â†‘b + â†‘c := by
  unfold sandbox.fma
  progress as âŸ¨x, xhâŸ©
  progress as âŸ¨y, yhâŸ©
  rw [yh, xh]
```

# è‡ªåˆ†ã®PCGé–¢æ•°ãŒå¸¸ã«æˆåŠŸã™ã‚‹ã“ã¨ã‚’è¨¼æ˜ã—ã¦ã¿ã‚‹

é ‘å¼µã£ã¦ã‚‚ã†å°‘ã—æœ‰ç”¨ãã†ãªè¨¼æ˜ã‚’è€ƒãˆã¦ã¿ã¾ã™ã€‚

ç­†è€…ã¯é€Ÿã„ä¹±æ•°ãŒæ¬²ã—ã„ã¨ãã«ã‚ˆãPCGã®`Pcg64Si`ã‚’Rustã§æ›¸ãã®ã§ã™ãŒãã‚ŒãŒçµ¶å¯¾ã«ãƒ‘ãƒ‹ãƒƒã‚¯ã›ãšè¿”ã‚Šå€¤ã‚’è¿”ã™ã“ã¨ã‚’è¨¼æ˜ã—ãŸã„ã¨æ€ã„ã¾ã™ã€‚

https://github.com/hatoo/oha/blob/a0002913331784299102d6dfe6d469ff7e4db2d5/src/pcg64si.rs#L1-L31

`rand::RngCore`ã¨ã‹ã‚’ä½¿ã†ã¨CharonãŒæ–‡å¥ã‚’ã„ã†ã®ã§èˆˆå‘³ãŒã‚ã‚‹éƒ¨åˆ†ã ã‘æŠœãå‡ºã—ã¾ã™

```rust
#[repr(transparent)]
pub struct Pcg64Si {
    state: u64,
}

impl Pcg64Si {
    pub fn next_u64(&mut self) -> u64 {
        let old_state = self.state;
        self.state = self
            .state
            .wrapping_mul(6364136223846793005)
            .wrapping_add(1442695040888963407);

        let word =
            ((old_state >> ((old_state >> 59) + 5)) ^ old_state).wrapping_mul(12605985483714917081);
        (word >> 43) ^ word
    }
}
```

Aeneasã®çµæœãŒã“ã¡ã‚‰ã€‚å‰²ã¨ã‚ã‹ã‚Šã‚„ã™ã„

```lean:Sandbox.lean
/- [sandbox::{sandbox::Pcg64Si}::next_u64]:
   Source: 'src/main.rs', lines 13:4-23:5 -/
def Pcg64Si.next_u64 (self : Pcg64Si) : Result (U64 Ã— Pcg64Si) :=
  do
  let i â†
    (â†‘(core.num.U64.wrapping_mul self.state 6364136223846793005#u64) : Result
      U64)
  let i1 â†
    (â†‘(core.num.U64.wrapping_add i 1442695040888963407#u64) : Result U64)
  let i2 â† self.state >>> 59#i32
  let i3 â† i2 + 5#u64
  let i4 â† self.state >>> i3
  let i5 â† (â†‘(i4 ^^^ self.state) : Result U64)
  let word â†
    (â†‘(core.num.U64.wrapping_mul i5 12605985483714917081#u64) : Result U64)
  let i6 â† word >>> 43#i32
  let i7 â† (â†‘(i6 ^^^ word) : Result U64)
  ok (i7, { state := i1 })
```

```lean:Basic.lean
-- Aeneasã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«xorã‚’å±•é–‹ã™ã‚‹ãŸã‚ã®ã‚„ã¤ãŒãªã‹ã£ãŸã®ã§ã“ã“ã§å®šç¾©ã—ã¦ã„ã‚‹ https://github.com/AeneasVerif/aeneas/issues/649
@[progress]
theorem UScalar.xor_spec {ty} (x y : UScalar ty) :
  âˆƒ z, toResult (x ^^^ y) = ok z âˆ§ z.val = (x ^^^ y).val âˆ§ z.bv = x.bv ^^^ y.bv := by
  simp [toResult]
  rfl

theorem Pcg64Si.next_u64_no_panic (self : sandbox.Pcg64Si) :
  âˆƒ res : U64 Ã— sandbox.Pcg64Si, self.next_u64 = ok res := by
  unfold sandbox.Pcg64Si.next_u64
  progress*
```

ã™ã¹ã¦ã®å…¥åŠ›ã«å¯¾ã—ã¦è¿”ã‚Šå€¤ãŒå­˜åœ¨ã—ã¦ã„ã‚‹ã“ã¨ã‚’ç¤ºã›ãŸã®ã§ã€`self.next_u64()`ã¯å¿…ãšæˆåŠŸã™ã‚‹ã“ã¨ãŒè¨¼æ˜ã§ããŸ

# ãŠã‚ã‚Šã«

ã¾ã Leanåˆå¿ƒè€…ãªã®ã§ã“ã‚Œä»¥ä¸Šã®ã“ã¨ã‚’è¨¼æ˜ã™ã‚‹ã“ã¨ã¯ã§ããªã‹ã£ãŸã€‚ç²¾é€²ã—ã¾ã™ã€‚