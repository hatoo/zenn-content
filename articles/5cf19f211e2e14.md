---
title: "Xorshiftを統計テストで落とそう！"
emoji: "💭"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: []
published: false
---

# はじめに

素のXorshift^[xoshiroなどの派生アルゴリズムは今回考えません]はよく線形過ぎて質が良くない(意訳)といわれます。
今回は実際に状態数32bitのXorshiftを統計テストで落としてみましょう！

# Xorshiftはビットベクトルの行列演算

C言語のXorshiftの実装コードを確認します。

```c
#include <stdint.h>

struct xorshift32_state {
  uint32_t a;
};

/* The state word must be initialized to non-zero */
uint32_t xorshift32(struct xorshift32_state *state)
{
	/* Algorithm "xor" from p. 4 of Marsaglia, "Xorshift RNGs" */
	uint32_t x = state->a;
	x ^= x << 13;
	x ^= x >> 17;
	x ^= x << 5;
	return state->a = x;
}
```

このXorshift特有の
```c
x ^= x << 13 /* なにか定数 */;
```
はビットベクトル上の行列積として表せます。

ということは

```c
	x ^= x << 13;
	x ^= x >> 17;
	x ^= x << 5;
```

この部分は全部合わせて一個の行列*ビットベクトルで表せます。

# じゃあなんなの？

本来理想的な乱数は独立しているべきですがXorshiftの出力はビットベクトルとしてみると一個前の出力にめちゃくちゃ依存しています。

# Matrix Rank

